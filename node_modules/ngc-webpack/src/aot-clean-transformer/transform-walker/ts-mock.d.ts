export declare const enum InternalSymbolName {
    Call = "__call",
    Constructor = "__constructor",
    New = "__new",
    Index = "__index",
    ExportStar = "__export",
    Global = "__global",
    Missing = "__missing",
    Type = "__type",
    Object = "__object",
    JSXAttributes = "__jsxAttributes",
    Class = "__class",
    Function = "__function",
    Computed = "__computed",
    Resolving = "__resolving__",
    ExportEquals = "export=",
    Default = "default",
}
/**
 * This represents a string whose leading underscore have been escaped by adding extra leading underscores.
 * The shape of this brand is rather unique compared to others we've used.
 * Instead of just an intersection of a string and an object, it is that union-ed
 * with an intersection of void and an object. This makes it wholly incompatible
 * with a normal string (which is good, it cannot be misused on assignment or on usage),
 * while still being comparable with a normal string via === (also good) and castable from a string.
 */
export declare type __String = (string & {
    __escapedIdentifier: void;
}) | (void & {
    __escapedIdentifier: void;
}) | InternalSymbolName;
/** ReadonlyMap where keys are `__String`s. */
export interface ReadonlyUnderscoreEscapedMap<T> {
    get(key: __String): T | undefined;
    has(key: __String): boolean;
    forEach(action: (value: T, key: __String) => void): void;
    readonly size: number;
    keys(): Iterator<__String>;
    values(): Iterator<T>;
    entries(): Iterator<[__String, T]>;
}
/** Map where keys are `__String`s. */
export interface UnderscoreEscapedMap<T> extends ReadonlyUnderscoreEscapedMap<T> {
    set(key: __String, value: T): this;
    delete(key: __String): boolean;
    clear(): void;
}
/** SymbolTable based on ES6 Map interface. */
export declare type SymbolTable = UnderscoreEscapedMap<Symbol>;
